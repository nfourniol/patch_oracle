#!/bin/bash

source ~/.bash_profile
readonly BASEDIR=$(dirname $0)
readonly INITIAL_DIRECTORY=$(pwd)
readonly PID=$$ # ID du process ex√©cutant refreshAutoCore
readonly TYPE_ERROR="ERROR"

# We load sources for Teams notification
source $BASEDIR/lib/teamsNotification

function execute_sql_on_cdb() {
	# Execute SQL on Container Database
	local sql="$1"
	echo "$sql"
	echo "$sql" | sqlplus / as sysdba
}

echo "Disk space verification"
# Configuration: Minimum size in GB required
REQUIRED_SPACE_GB=15
REQUIRED_SPACE_BYTES=$((REQUIRED_SPACE_GB * 1024 * 1024 * 1024))

# Checks that the ORACLE_BASE and ORACLE_HOME variables are defined
if [[ -z "$ORACLE_BASE" && -z "$ORACLE_HOME" ]]; then
    echo "ERROR: ORACLE_BASE and ORACLE_HOME are not defined. Cannot proceed."
    exit 1
fi

# Use ORACLE_BASE as priority, otherwise fallback to ORACLE_HOME
ORACLE_DIR=${ORACLE_BASE:-$ORACLE_HOME}

# Find the mount point associated with ORACLE_DIR
MOUNT_POINT=$(df --output=target "$ORACLE_DIR" | tail -1)

if [[ -z "$MOUNT_POINT" ]]; then
    echo "ERROR: Unable to determine the mount point for $ORACLE_DIR."
    exit 1
fi

echo "Oracle directory: $ORACLE_DIR"
echo "Detected mount point: $MOUNT_POINT"

# Recovers free space for the mount point
AVAILABLE_BYTES=$(df --output=avail --block-size=1 "$MOUNT_POINT" | tail -1)

if [[ -z "$AVAILABLE_BYTES" || "$AVAILABLE_BYTES" -eq 0 ]]; then
    echo "ERROR: Unable to determine available space on $MOUNT_POINT."
    exit 1
fi

echo "Available space on $MOUNT_POINT: $((AVAILABLE_BYTES / 1024 / 1024 / 1024)) GB"

# Check that there is enough space available
if [[ $AVAILABLE_BYTES -lt $REQUIRED_SPACE_BYTES ]]; then
    echo "ERROR: Insufficient disk space. At least ${REQUIRED_SPACE_GB}GB is required."
    exit 1
fi


echo "Disk space is sufficient to apply the patch"
echo "Check that the script is being executed as an oracle user"
if [ "$(whoami)" != "oracle" ]; then
    	echo "ERROR: you should execute this script as an oracle user"
	exit 1
fi

echo "Tests the existence of ORACLE_BASE"
if [ -z "$ORACLE_BASE" ] || [ ! -d "$ORACLE_BASE" ]; then
	echo "ERROR: the environment variable ORACLE_BASE is incorrect: empty or targets on a non existing directory. ORACLE_BASE=$ORACLE_BASE"
	exit 1
fi

echo "Tests the existence of ORACLE_HOME"
if [ -z "$ORACLE_HOME" ] || [ ! -d "$ORACLE_HOME" ]; then
	echo "ERROR: the environment variable ORACLE_HOME is incorrect: empty or targets on a non existing directory. ORACLE_HOME=$ORACLE_HOME"
	exit 1
fi

echo "Tests the existence of patch_oracle.conf"
if [ ! -f $BASEDIR/patch_oracle.conf ] || [ ! -r $BASEDIR/patch_oracle.conf ]; then
	echo "ERROR: Impossible to read $BASEDIR/patch_oracle.conf"
	exit 1
fi


echo "Read of $BASEDIR/patch_oracle.conf"
declare -A properties
configuration_file="$BASEDIR/patch_oracle.conf"
while IFS='=' read -r key value; do
    # Read of patch_oracle.conf (properties file), we remove comments of type # ... using the sed command
    value=$(echo $value | sed 's/[[:space:]]//g' | sed 's/\#.*//g')
    if [ ! -z "$key" ]; then # If a line is empty, then key is empty
        properties["$key"]="$value"
    fi
done < "$configuration_file"

echo "Extract values from $BASEDIR/patch_oracle.conf"
oracle_opatch_fullpath=${properties["oracle.opatch.fullpath"]}
oracle_patch_fullpath=${properties["oracle.patch.fullpath"]}
oracle_patch_directory=${properties["oracle.patch.directory"]}
smtp_host=${properties["mail.smtp_host"]}
mail_to=${properties["mail.mail_to"]}
mail_from=${properties["mail.mail_from"]}
teams_workflow=${properties["teams.workflow.tecinfra"]}

endPatch() {
    # This funtion should be the last treatment executed

	type=$1
	msg=$2

	object="Patch successfully applied on host $HOSTNAME"
	if [ "$type" == "$TYPE_ERROR" ]; then
		object="Patch oracle error application on host $HOSTNAME"
	fi

	if [ ! -z "$smtp_host" ]; then
		echo "An email is sent to inform you that '$object'"
		${BASEDIR}/lib/sendMail.sh $smtp_host $mail_from "'$mail_to'" "$object" "$msg"
	fi
	if [ ! -z "$teams_workflow" ]; then
		echo "Sends a Teams notification to inform you that '$object'"
		send_blue_notification "$teams_workflow" "$msg"
	fi

	echo "Delete the PID file : $PID.patch_oracle"
    rm -f $BASEDIR/$PID.patch_oracle

	if [ "$type" == "$TYPE_ERROR" ]; then
		exit 1
    else
		exit 0
    fi
}

startPatch() {
    # This funtion is used to create $PID.patch_oracle file
    local testAlreadyOnePatchExecution
    testAlreadyOnePatchExecution=$(ls | grep -E '[0-9]+\.patch_oracle')
    if [ ! -z "$testAlreadyOnePatchExecution" ]; then
        echo "ERROR $testAlreadyOnePatchExecution found"
        endPatch $TYPE_ERROR "ERROR $testAlreadyOnePatchExecution found: there is another patch_oracle that is currently executed"
    else
        echo "Patch process started. Process ID = $PID"
        touch $BASEDIR/$PID.patch_oracle
    fi
}

startPatch

echo "Tests the existence of oracle.opatch.fullpath and oracle.patch.fullpath"
if [ -z "$oracle_opatch_fullpath" ] || [ -z "$oracle_patch_fullpath" ]; then
	endPatch "$TYPE_ERROR" "ERROR: the patch script configuration variables oracle_opatch_fullpath and oracle_patch_fullpath are empty: oracle_opatch_fullpath=$oracle_opatch_fullpath and oracle_patch_fullpath=$oracle_patch_fullpath"
fi

echo "Tests the existence of oracle.opatch.fullpath"
if [ ! -f "$oracle_opatch_fullpath" ] || [ ! -r "$oracle_opatch_fullpath" ]; then
	endPatch "$TYPE_ERROR" "ERROR: the OPatch file $oracle_opatch_fullpath does not exist or does not have read permissions"
fi

echo "Tests the existence of oracle.patch.fullpath"
if [ ! -f "$oracle_patch_fullpath" ] || [ ! -r "$oracle_patch_fullpath" ]; then
	endPatch "$TYPE_ERROR" "ERROR: the patch file $oracle_patch_fullpath does not exist or does not have read permissions"
fi

echo "Teste l'exactitude de oracle.patch.directory"
test_oracle_patch_directory=$(unzip -p $oracle_patch_fullpath $oracle_patch_directory/)
if [ ! -z "$test_oracle_patch_directory" ]; then
	endPatch "$TYPE_ERROR" "ERROR: The $oracle_patch_directory folder was not found in the patch zip. Check oracle.patch.directory in the conf"
fi

# Environment variables that should be set
export PATH=$ORACLE_HOME/bin:$PATH:$ORACLE_HOME/OPatch
export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib
export CLASSPATH=$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib

current_opatch_version=$(cat $ORACLE_HOME/OPatch/version.txt | cut -d ':' -f 2)
echo "current_opatch_version=$current_opatch_version"
new_opatch_version=$(unzip -p $oracle_opatch_fullpath OPatch/version.txt | cut -d ':' -f 2)
echo "new_opatch_version=$new_opatch_version"


if [ "$new_opatch_version" == "$current_opatch_version" ]; then
	echo "No OPatch update, the current version is up to date"
else
	echo "Comparison between opatch versions: current=$current_opatch_version new=$new_opatch_version"
	new_opatch_is_older=false
	for i in 1 2 3 4 5
	do
		current_digit=$(echo $current_opatch_version | cut -d '.' -f $i)
		new_digit=$(echo $new_opatch_version | cut -d '.' -f $i)
		echo "comparaison entre new_digit=$new_digit et current_digit=$current_digit"
		if [ "$new_digit" -lt "$current_digit" ]; then
			new_opatch_is_older=true
		fi
	done
	
	if [ "$new_opatch_is_older" = true ]; then
		echo "No OPatch update, the current version is more recent"
	else
		echo "Updating OPatch from $current_opatch_version to $new_opatch_version"
		echo "mv $ORACLE_HOME/OPatch $ORACLE_HOME/OPatch.old.v${current_opatch_version}"
		mv $ORACLE_HOME/OPatch $ORACLE_HOME/OPatch.old.v${current_opatch_version}
		echo "unzip of the new OPatch :"
		unzip $oracle_opatch_fullpath -d $ORACLE_HOME/
	fi
fi

echo "Oracle listener stop"
lsnrctl stop
# we ensure database is stopped
execute_sql_on_cdb "shutdown immediate;"

if [ ! -d $ORACLE_BASE/patch ]; then
    echo "Create patch folder in $ORACLE_BASE/ ==> $ORACLE_BASE/patch"
	mkdir $ORACLE_BASE/patch
fi

echo "unzip -o $oracle_patch_fullpath -d $ORACLE_BASE/patch/"
# unzip with the -o option to overwrite PatchSearch.xml, which is at the root of the patch zips
# This avoids the question: replace /u01/app/oracle/patch/PatchSearch.xml? [y]es, [n]o, [A]ll, [N]one, [r]ename: y
unzip -o $oracle_patch_fullpath -d $ORACLE_BASE/patch/
cd $ORACLE_BASE/patch/$oracle_patch_directory/
directories=$(cat README.html | grep -B 2 'opatch apply' | grep UNZIPPED_PATCH_LOCATION | grep -o -E '[1-9]*')
i=0
for dir in $directories; do
	if [ "$i" = "1" ]; then
		cd $dir;
	fi
	((i++)) 
done # Move to the patch folder to perform an opatch apply
echo "Current directory = $(pwd)"

echo "opatch apply -jdk $ORACLE_HOME/jdk"

##
yes | opatch apply -jdk $ORACLE_HOME/jdk
opatch_apply_result_code=$?
##

echo "opatch apply returned the result code: $opatch_apply_result_code"
if [ ! "$?" = "0" ]; then
	endPatch "$TYPE_ERROR" "ERROR: opatch apply failed!!!"
fi

# we ensure database is started because we shut it previously.
execute_sql_on_cdb "startup;"

echo "Start the oracle listener"
lsnrctl start


lnrctl_status=$(lsnrctl status | grep "The listener supports no services")
echo "Wait for listener to be correctly started and list of services"
count=0
while [ ! -z "$lnrctl_status" ] && [ "$count" -lt "300" ]
do
	((count++))
	sleep 1
	echo -n "."
	lnrctl_status=$(lsnrctl status | grep "The listener supports no services")
done
echo "Patch was applied with success. Now we clean disk from the unzip patch: rm -rf $ORACLE_BASE/patch/$oracle_patch_directory"
rm -rf $ORACLE_BASE/patch/$oracle_patch_directory

if [ -d $ORACLE_HOME/OPatch.old.v${current_opatch_version} ]; then
	echo "!!! you can remove $ORACLE_HOME/OPatch.old.v${current_opatch_version} to free space if you want !!!"
fi
echo "==============================================="
echo "Success: End of application of the oracle patch"
echo "==============================================="

endPatch "Success" "Success: End of application of the oracle patch"
